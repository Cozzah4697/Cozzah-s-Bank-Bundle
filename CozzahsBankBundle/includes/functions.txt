# A neat messaging function
function void entity:msg(Text:string) {
    if (!This:isValid()) {return}
    This:tauSendChatMsg(Text)
}

# A neat find player function
function entity string:findPlayer() {
    return This:sub(1, 5):upper() == "STEAM" ? findPlayerBySteamID(This) : findPlayerByName(This)
}

# format money to easy to read string e.g. 2500000 = 25M
function string formatNumber(N:number) {
    if(N >= 1000000) {
        return (floor(N/10000)/100) + "M"
    }
    elseif(N >= 1000) {
        return (floor(N/10)/100) + "K"
    }
    return toString(floor(N,0))
}

function string formatNumberComma(N:number) {
    local Str = toString(N)
    local Result = ""
    local Count = 0
    
    for(I = Str:length(), 1, -1) {
        Count = Count + 1
        Result = Str:sub(I, I) + Result
        
        if(Count % 3 == 0 && I > 1) {
            Result = "," + Result
        }
    }
    
    return Result
}

function string formatTimeInSeconds(Number:number) {
    if (Number >= 60) {
        Minutes = floor(Number / 60)
        Seconds = floor(Number % 60)
        
        MinText = Minutes + (Minutes == 1 ? " min" : " mins")
        
        if (Seconds > 0) {
            SecText = Seconds + (Seconds == 1 ? " sec" : " secs")
            return MinText + " " + SecText
        } else {
            return MinText
        }
    }
    return floor(Number) + (floor(Number) == 1 ? " sec" : " secs")
}

# Function to limit name length and add ellipsis if needed
function string limitNameLength(Name:string, MaxLength:number) {
    if(Name:length() <= MaxLength) {
        return Name
    }
    
    return Name:sub(1, MaxLength - 3) + "..."
}

function string capitalizeFirst(Text:string) {
    if(Text:length() == 0) { return "" }
    return Text:sub(1,1):upper() + Text:sub(2)
}

function number string:startsWith(String:string) {
    return This:left(String:length()) == String
}

function void distanceCheck(Player:entity, Max:number, Next:function) {
    let E2Pos = entity():pos()
    timer("distanceCheck",1,0,function() {
        if(!Player:isValid()) {
            stoptimer("distanceCheck")
            Next()
        }
        let PlayerPos = Player:pos()
        let Distance = E2Pos:distance(PlayerPos)
        
        if(Distance > Max) {
            stoptimer("distanceCheck")
            Next()
        }
    })
}

function void distanceCheck2(Player1:entity, Player2:entity, Max:number, Next:function) {
    let E2Pos = entity():pos()
    timer("distanceCheck",1,0,function() {
        if(Player1:isValid()) {
            let Player1Pos = Player1:pos()
            let Distance1 = E2Pos:distance(Player1Pos)
            if(Distance1 > Max) {
                stoptimer("distanceCheck")
                Next()
            }
        }
        
        if(Player2:isValid()) {
            let Player2Pos = Player1:pos()
            let Distance2 = E2Pos:distance(Player2Pos)
            if(Distance2 > Max) {
                stoptimer("distanceCheck")
                Next()
            }
        }
    })
}

function void distanceFromEntity(Player:entity, Entity:entity, Max:number, Next:function) {
    let EntityPos = Entity:pos()
    timer("distanceFromEntity",1,0,function() {
        if(!Player:isValid()) {
            stoptimer("distanceFromEntity")
            Next()
        }
        let Distance = EntityPos:distance(Player:pos())
        if(Distance > Max) {
            stoptimer("distanceFromEntity")
            Next()
        }
    })
}
            

function string getLastSection(Str:string) {
    local UnderscorePos = 0
    for(I = 1, Str:length()) {
        if(Str:sub(I, I) == "_") {
            UnderscorePos = I
        }
    }
    if(UnderscorePos > 0) {
        return Str:sub(UnderscorePos + 1)
    }
    return Str
}

function void playerInRange(DetectionRadius:number, Do:function, Else:function) {
    let E2Pos = entity():pos()
    let PlayerInRangeState = 0
    
    # Stop existing timer if running
    if(timerExists("playerRangeCheck")) {
        stoptimer("playerRangeCheck")
    }
    
    # Initialize state if first time
    if(first()) {
        PlayerInRangeState = 0
    }
    
    # Start new timer with a name
    timer("playerRangeCheck", 1, 0, function() {
        findClearBlackList()
        findClearWhiteList()
        findIncludeClass("player")
        findInSphere(E2Pos, DetectionRadius)
        
        # Player found
        if(findResult(1)) {
            # Only run the Do function if state is changing
            if(PlayerInRangeState == 0) {
                PlayerInRangeState = 1
                Do()
            }
        }
        # No player found
        else {
            # Only run the Else function if state is changing
            if(PlayerInRangeState == 1) {
                PlayerInRangeState = 0
                Else()
            }
        }
    })
}
    
function entity wirelink:userRanger(Length:number) {
    local UserEntity = This:entity()
    if(!UserEntity:isValid()) {
        return _NO_ENTITY
    }
    
    if(UserEntity:getClass() != "gmod_wire_user") {
        error("userRanger entity must be gmod_wire_user")
    }
    
    rangerReset()
    rangerFlags("IE")
    rangerFilter(UserEntity)
    local Ranger = rangerOffset(Length, UserEntity:toWorld(vec(0,0,1.5)), UserEntity:up())
    
    return Ranger:entity()
}

function entity findE2ByName(Name:string, Radius:number) {
    local Position = entity():pos()  # Current E2's position
    findInSphere(Position, Radius)
    local Entities = findToArray()
    
    for (I = 1, Entities:count()) {
        local Ent = Entities[I, entity]
        
        # Check if it's an E2 and has the right name
        if (Ent:getClass() == "gmod_wire_expression2" & Ent:getName() == Name) {
            return Ent
        }
    }
    
    return _NO_ENTITY
}

function number array:findEntity(E:entity) {
    for (I = 1, This:count()) {
        if (This[I, entity] == E) {return I}
    }
    return 0
}

#[# ------------------------------------------------------------------------------------------------------------------------------------
# BANKER E2 FUNCTIONS
# ------------------------------------------------------------------------------------------------------------------------------------

# Function to get tier name from number
function string getTierName(Tier:number) {
    # Constants for MemberData Tiers
    const TIER_SILVER = 1
    const TIER_GOLD = 2
    const TIER_DIAMOND = 3

    
    if(Tier == TIER_SILVER) { return "Silver" }
    elseif(Tier == TIER_GOLD) { return "Gold" }
    elseif(Tier == TIER_DIAMOND) { return "Diamond" }
    return "Copper"
}

# Function to get a player's membership tier
function number getMemberDataTier(Player:entity, MemberData:table) {
    if(!Player:isValid()) { return 0 }
    
    let SteamID = Player:steamID()
    
    # If they have no membership, return 0
    if(!MemberData:exists(SteamID)) {
        return 0
    }
    
    # Convert the string value to a number before returning
    return MemberData[SteamID, number]
}

function number getTax(Player:entity, MemberData:table) {
    if(!Player:isValid()) { return 0 }
    
    let SteamID = Player:steamID()
    
    # If they have no membership, return 0
    if(!MemberData:exists(SteamID)) { return 0.35 }
    let Tier = MemberData[SteamID, number]
    
    if(Tier == 3) { return 0.10 }
    elseif(Tier == 2) { return 0.20 }
    elseif(Tier == 1) { return 0.25 }
    else { return 0.10 }
}]#
