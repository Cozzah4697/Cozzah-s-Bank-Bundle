@name Cozzah's Banker E2 Main
#V1.4
@inputs [HUD]:wirelink
@outputs [TimeLeft OverallTotalTax OverallTotalProfit RackAvgProfitPerHour]:number

@persist [MemberData Racks Guards PendingPayouts Elements CrashRecoveryData]:table
@persist [LastCustomerSteamID LastTierName LastTaxTotal LastProfitTotal]:string
@persist [Snapshot TimeLeft CurrentRackID HUDX HUDY ServerCrashed RackProfitStartTime]:number
@persist [CurrentCustomer]:entity
@persist [JOB]:array

#include "CozzahsBankBundle/includes/functions"
#include "CozzahsBankBundle/includes/membership_configuration"

if(first() || dupefinished()) {    
    # ========== HUD POSITION SETTINGS ==========
    #changes printer HUD from default position
    #"HUDX = 100" = default HUD X position +100 pixels to the RIGHT
    #"HUDX = -100" = default HUD X position +100 pixels to the LEFT
    #"HUDY = 100" = default HUD Y position +100 pixels to the DOWN
    #"HUDY = -100" = default HUD Y position +100 pixels to the UP
    HUDX = 0
    HUDY = 0
    # ============================================
    
    #==================================DO NOT TOUCH PAST THIS POINT==================================#
    
    Snapshot = 0
    CurrentRackID = 0
    LastCustomerSteamID = ""
    LastTierName = ""
    LastTaxTotal = ""
    LastProfitTotal = ""
    
    OverallTotalTax = 0
    OverallTotalProfit = 0
    ServerCrashed = 0
    
    Elements = table()
    MemberData = table()
    Racks = table()
    Guards = table()
    PendingPayouts = table()
    CrashRecoveryData = table()
    CurrentCustomer = _NO_ENTITY
    RackProfitStartTime = curtime()
    JOB = array("Police Officer", "Police Chief", "SWAT", "SWAT Medic", "SWAT Sniper", "Secret Service", "CUSTOM_POLICE")
}

# Insurance price table
function number getInsurancePrice(ItemName:string) {
    if(ItemName == "Standard Rack") { return 25000 }
    elseif(ItemName == "Pro Rack") { return 100000 }
    elseif(ItemName == "Basic") { return 30000 }
    elseif(ItemName == "Advanced") { return 60000 }
    elseif(ItemName == "Tier 5") { return 75000 }
    elseif(ItemName == "VIP") { return 200000 }
    elseif(ItemName == "VIP+") { return 275000 }
    elseif(ItemName == "Epic") { return 375000 }
    elseif(ItemName == "Legendary") { return 450000 }
    elseif(ItemName == "Halloween") { return 375000 }
    elseif(ItemName == "Christmas") { return 375000 }
    elseif(ItemName == "Booster") { return 275000 }
    elseif(ItemName == "Black Wing") { return 450000 }
    elseif(ItemName == "BitMiner Rack") { return 25000 }
    elseif(ItemName == "BitMiner Tower") { return 100000 }
    elseif(ItemName == "BitMiner Tower Pro") { return 250000 }
    return 0
}

function number table:get(...Args:array) {
    const Name = Args[1, string]
    if (Name) {
        if (This:exists(Name)) {
            return This[Name, number]   
        }
        const FreeID = This:flip():ncount()+1
        This[Name, number] = FreeID
        return FreeID
    }
    const FreeID = This:flip():ncount()+1
    This[toString(FreeID), number] = FreeID
    return FreeID
}

function void wirelink:clear() {
    This:egpClear()
    Elements:clear()
}


function egpobject text(ID:number, ARGS:table) {
    return HUD:egpTextLayout(ID, ARGS)
}

function egpobject circle(ID:number, ARGS:table) {
    if (ARGS["outline", number]) {
        return HUD:egpCircleOutline(ID, ARGS)
    }
    return HUD:egpCircle(ID, ARGS)
}

function egpobject box(ID:number, ARGS:table) {
    if (ARGS["outline", number]) {
        return HUD:egpRoundedBoxOutline(ID, ARGS)
    }
    return HUD:egpRoundedBox(ID, ARGS)
}

function egpobject line(ID:number, ARGS:table) {
    return HUD:egpBox(ID, ARGS)
}

# Removes only the printer hud objects so that the timer does not get cleared
# Could of renamed the objects to have "printer" then just loop through all objects to remove them
# This would make it easier  to add printer hud objects later but i do not see that being needed
function removeCard() {
    HUD:egpRemove(Elements:get("Ellipse88"))
    HUD:egpRemove(Elements:get("Ellipse89"))
    HUD:egpRemove(Elements:get("Ellipse90"))
    HUD:egpRemove(Elements:get("Ellipse91"))
    HUD:egpRemove(Elements:get("Rectangle381"))
    HUD:egpRemove(Elements:get("Rectangle382"))
    HUD:egpRemove(Elements:get("Rectangle383"))
    HUD:egpRemove(Elements:get("Rectangle384"))
    HUD:egpRemove(Elements:get("OWNERSRACK"))
    HUD:egpRemove(Elements:get("CUSTOMER"))
    HUD:egpRemove(Elements:get("COZZAH"))
    HUD:egpRemove(Elements:get("TIER"))
    HUD:egpRemove(Elements:get("DIAMOND"))
    HUD:egpRemove(Elements:get("TAX"))
    HUD:egpRemove(Elements:get("$999M"))
    HUD:egpRemove(Elements:get("PROFIT"))
    HUD:egpRemove(Elements:get("1" + "$999M"))
    HUD:egpRemove(Elements:get("Rectangle385"))
    HUD:egpRemove(Elements:get("Rectangle388"))
    HUD:egpRemove(Elements:get("Rectangle389"))
    HUD:egpRemove(Elements:get("Rectangle387")) 
}

# save overall totals to a file:
function void saveOverallTotals() {
    if(fileCanWrite()) {
        let Data = table(
            "overall_tax" = OverallTotalTax,
            "overall_profit" = OverallTotalProfit
        )
        fileWrite("banker_overall_totals.txt", jsonEncode(Data, 1))
    }
}

# load overall totals from file:
function void loadOverallTotals() {
    if(fileCanLoad()) {
        fileLoad("banker_overall_totals.txt")
    }
}

function void loadCrashRecoveryData() {
    if(fileCanLoad()) {
        fileLoad("cozzahs_bank_crash_recovery.txt")
    } else {
        CrashRecoveryData = table()
        print("{! Crash recovery file not found, starting fresh}")
    }
}

function void saveCrashRecoveryValue(SteamID:string, TotalValue:number) {
    # Add to existing value if player already has a saved value
    local CurrentValue = CrashRecoveryData[SteamID, number]
    CrashRecoveryData[SteamID, number] = CurrentValue + TotalValue
    
    # Save to file
    fileWrite("cozzahs_bank_crash_recovery.txt", jsonEncode(CrashRecoveryData))
}

function number checkRack(Entity:entity) {
    if (Entity:isValid()) {
        let Class = Entity:keyvalues()["classname", string]
        return Class:startsWith("printer_rack") || Class:startsWith("bitminer_tower")
    }
    return 0
}

function void checkProfit(Customer:entity) {
    let Amount = owner():money() - Snapshot
    
    if(Amount > 1000) {        
        let Name = Customer:name():upper()
        let AimEntity = owner():aimEntity()
        let RackID = AimEntity:id()
        let SteamID = Customer:steamID()

        # Use effective tier (highest of perm or temp) for tax calculation
        let Tax = Guards:exists(SteamID) ? 0 : getTax(Customer, MemberData)
        let TaxAmount = Amount * Tax
        let Profit = Amount - TaxAmount
        # Update overall totals
        OverallTotalTax += TaxAmount
        OverallTotalProfit += Profit
        saveOverallTotals()
        
        if(Amount == getTierCost(TIER_SILVER) || Amount == getTierCost(TIER_GOLD) || Amount == getTierCost(TIER_DIAMOND) || Amount == getTierCostTemp(TIER_SILVER) || Amount == getTierCostTemp(TIER_GOLD) || Amount == getTierCostTemp(TIER_DIAMOND)) {
            owner():msg("{!yellow [" + BankName + "]} {! Auto Payment aborted due to being detected as a membership payment}. if this is a mistake use chat command {yellow '*WIRE " + Customer:name() + " " + Profit + "'}")
            break
        }
        
        # Update the tax total AND profit total for this rack
        if(Racks[RackID, table]) {
            let CurrentTax = Racks[RackID, table]["tax_total", number]
            let CurrentProfit = Racks[RackID, table]["profit_total", number]
            
            Racks[RackID, table]["tax_total", number] = CurrentTax + TaxAmount
            Racks[RackID, table]["profit_total", number] = CurrentProfit + Profit
        }
        
        owner():msg("{!yellow [" + BankName + "]} You collected: {green $" + formatNumber(TaxAmount) + "} in taxes.")
        
        # Check if there's already a pending payout for this player
        if(!PendingPayouts:exists(SteamID)) {
            # Create new payout entry
            PendingPayouts[SteamID, table] = table(
                "total_tax" = TaxAmount,
                "total_profit" = Profit,
                "rack_count" = 1,
                "tax_rate" = Tax,
                "name" = Name
            )
            
            # Start timer to send message after 5 seconds
            timer("payout_" + SteamID, 5, function() {
                if(PendingPayouts:exists(SteamID)) {
                    let PayoutData = PendingPayouts[SteamID, table]
                    let FinalTaxAmount = PayoutData["total_tax", number]
                    let FinalProfit = PayoutData["total_profit", number]
                    let RackCount = PayoutData["rack_count", number]
                    let FinalTax = PayoutData["tax_rate", number]
                    let FinalName = PayoutData["name", string]
                    
                    let FinalCustomer = SteamID:findPlayer()
                    if(FinalCustomer:isValid()) {
                        let PlayerTier = getEffectiveTier(FinalCustomer, MemberData)
                        let TierName = getTierName(PlayerTier):upper()
                        let Colour = getTierColor(PlayerTier)
                        
                        let RackText = RackCount > 1 ? " {blue from " + RackCount + " racks}" : ""
                        
                        # Get lifetime totals from rack data
                        let LifetimeTax = 0
                        let LifetimeProfit = 0
                        
                        foreach(_:number, RackData:table = Racks) {
                            if(RackData["owner", string] == SteamID) {
                                LifetimeTax += RackData["tax_total", number]
                                LifetimeProfit += RackData["profit_total", number]
                            }
                        }
                        
                        # Send main payment message
                        FinalCustomer:msg("{!yellow [" + BankName + "]} Thanks for banking with us, {yellow " + FinalName + "}! You received: {green $" + formatNumber(FinalProfit) + "}" + RackText)
                        
                        # Send tier-specific tax and lifetime info
                        if(Guards:exists(SteamID)) {
                            FinalCustomer:msg("{!yellow [" + BankName + "]} Tax paid: {green $" + formatNumber(FinalTaxAmount) + " (" + (FinalTax*100) + "%)} as {blue security guard}")
                        } 
                        elseif(PlayerTier == TIER_DIAMOND) {
                            FinalCustomer:msg("{!yellow [" + BankName + "]} Tax: {green $" + formatNumber(FinalTaxAmount) + " (" + (FinalTax*100) + "%)} {" + Colour + " " + TierName + "} | Profit {green $" + formatNumber(LifetimeProfit) + "}")
                        } 
                        else {
                            # Non-Diamond tier - show upgrade incentive
                            let DiamondTax = getTierTax(TIER_DIAMOND)
                            let PotentialSavings = LifetimeTax - (LifetimeProfit + LifetimeTax) * DiamondTax
                            
                            if(PotentialSavings > 5000000) {
                                FinalCustomer:msg("{!yellow [" + BankName + "]} Tax: {red $" + formatNumber(FinalTaxAmount) + " (" + (FinalTax*100) + "%)} {" + Colour + " " + TierName + "} | Lifetime: Tax {red $" + formatNumber(LifetimeTax) + "}  Profit {green $" + formatNumber(LifetimeProfit) + "} | {! Upgrade to Diamond and save $" + formatNumber(PotentialSavings) + "!}")
                            } else {
                                FinalCustomer:msg("{!yellow [" + BankName + "]} Tax: {red $" + formatNumber(FinalTaxAmount) + " (" + (FinalTax*100) + "%)} {" + Colour + " " + TierName + "} | Lifetime: Tax {red $" + formatNumber(LifetimeTax) + "}  Profit {green $" + formatNumber(LifetimeProfit) + "}")
                            }
                        }
                        
                        moneyGive(FinalCustomer, FinalProfit)
                    }
                    
                    # Clear the pending payout
                    PendingPayouts:remove(SteamID)
                }
            })
        }
        else {
            # Add to existing payout
            let PayoutData = PendingPayouts[SteamID, table]
            PayoutData["total_tax", number] = PayoutData["total_tax", number] + TaxAmount
            PayoutData["total_profit", number] = PayoutData["total_profit", number] + Profit
            PayoutData["rack_count", number] = PayoutData["rack_count", number] + 1
        }

        Snapshot = 0
    }
}

function void checkCollection() {
    let AimEntity = owner():aimEntity()
    if(checkRack(AimEntity)) {
        let Customer = _NO_ENTITY 
        let RackID = AimEntity:id()
        
        # Try to get customer from table first
        if(Racks[RackID, table]) {
            let RackData = Racks[RackID, table]
            let SteamID = RackData["owner", string]
            Customer = SteamID:findPlayer()
            
            # If player not found by SteamID, fall back to entity owner
            if(!Customer:isValid()) {
                Customer = AimEntity:owner()
            }
        }
        else {
            # If rack not in table, clear and reset tracking variables
            if(CurrentCustomer:isValid() || CurrentRackID != 0) {
                CurrentCustomer = _NO_ENTITY
                CurrentRackID = 0
                Snapshot = 0
                LastCustomerSteamID = ""
                LastTierName = ""
                LastTaxTotal = ""
                LastProfitTotal = ""
                removeCard()
            }
            return
        }
        
        # Check if customer is valid
        if(Customer:isValid()) {
            let SteamID = Customer:steamID()
            let PlayerTier = getEffectiveTier(Customer, MemberData)
            let TierName = Guards:exists(SteamID) ? "GUARD" : getTierName(PlayerTier):upper()
            let TierR = Guards:exists(SteamID) ? 20 : getTierColorR(PlayerTier)
            let TierG = Guards:exists(SteamID) ? 20 : getTierColorG(PlayerTier)
            let TierB = Guards:exists(SteamID) ? 200 : getTierColorB(PlayerTier)
            
            # Get tax and profit totals
            let TaxTotal = 0
            let ProfitTotal = 0
            if(Racks[RackID, table]) {
                TaxTotal = Racks[RackID, table]["tax_total", number]
                ProfitTotal = Racks[RackID, table]["profit_total", number]
            }
            
            let TaxTotalStr = "$" + formatNumber(TaxTotal)
            let ProfitTotalStr = "$" + formatNumber(ProfitTotal)
            
            # Check if any data changed
            if(Customer != CurrentCustomer || RackID != CurrentRackID || 
               SteamID != LastCustomerSteamID || TierName != LastTierName || 
               TaxTotalStr != LastTaxTotal || ProfitTotalStr != LastProfitTotal) {
                
                # Update tracking variables
                CurrentCustomer = Customer
                CurrentRackID = RackID
                LastCustomerSteamID = SteamID
                LastTierName = TierName
                LastTaxTotal = TaxTotalStr
                LastProfitTotal = ProfitTotalStr
                Snapshot = owner():money()
                
                # Determine entity type
                let Class = AimEntity:keyvalues()["classname", string]
                let EntityType = ""
                if(Class:startsWith("printer_rack")) { EntityType = "RACK" }
                elseif(Class:startsWith("bitminer_tower")) { EntityType = "TOWER" }
                
                # Redraw HUD with exact positioning from Figma using HUDX and HUDY offsets
                circle(Elements:get("Ellipse88"), table("x"=HUDX+327.5, "y"=HUDY+470.5, "w"=21.5, "h"=21.5, "r"=TierR, "g"=TierG, "b"=TierB))
                circle(Elements:get("Ellipse89"), table("x"=HUDX+327.5, "y"=HUDY+857.5, "w"=21.5, "h"=21.5, "r"=TierR, "g"=TierG, "b"=TierB))
                circle(Elements:get("Ellipse90"), table("x"=HUDX+68.5, "y"=HUDY+470.5, "w"=21.5, "h"=21.5, "r"=TierR, "g"=TierG, "b"=TierB))
                circle(Elements:get("Ellipse91"), table("x"=HUDX+68.5, "y"=HUDY+857.5, "w"=21.5, "h"=21.5, "r"=TierR, "g"=TierG, "b"=TierB))
                box(Elements:get("Rectangle381"), table("x"=HUDX+71.0, "y"=HUDY+449.0, "w"=259.0, "h"=430.0, "r"=42, "g"=42, "b"=42, "radius"=0))
                box(Elements:get("Rectangle382"), table("x"=HUDX+47.0, "y"=HUDY+470.0, "w"=302.0, "h"=388.0, "r"=42, "g"=42, "b"=42, "radius"=0))
                box(Elements:get("Rectangle383"), table("x"=HUDX+71.0, "y"=HUDY+449.0, "w"=259.0, "h"=43.0, "r"=89, "g"=89, "b"=89, "radius"=0))
                box(Elements:get("Rectangle384"), table("x"=HUDX+47.0, "y"=HUDY+470.0, "w"=302.0, "h"=22.0, "r"=89, "g"=89, "b"=89, "radius"=0))
                text(Elements:get("OWNERSRACK"), table("text"=limitNameLength(Customer:name():upper(),9) + "'S " + EntityType, "x"=HUDX+71.0, "y"=HUDY+449.0, "w"= 259.0, "h"=43.0, "r"=255, "g"=255, "b"=255, "size"=27, "halign"=1, "valign"=1))
                text(Elements:get("CUSTOMER"), table("text"="CUSTOMER:", "x"=HUDX+47.0, "y"=HUDY+492.0, "w"= 302.0, "h"=43.0, "r"=255, "g"=215, "b"=0, "size"=27, "halign"=1, "valign"=1))
                text(Elements:get("COZZAH"), table("text"=limitNameLength(Customer:name():upper(),16), "x"=HUDX+47.0, "y"=HUDY+535.0, "w"= 302.0, "h"=43.0, "r"=255, "g"=215, "b"=0, "size"=27, "halign"=1, "valign"=1))
                text(Elements:get("TIER"), table("text"="TIER:", "x"=HUDX+47.0, "y"=HUDY+578.0, "w"= 302.0, "h"=43.0, "r"=TierR, "g"=TierG, "b"=TierB, "size"=27, "halign"=1, "valign"=1))
                text(Elements:get("DIAMOND"), table("text"=TierName, "x"=HUDX+47.0, "y"=HUDY+621.0, "w"= 302.0, "h"=43.0, "r"=TierR, "g"=TierG, "b"=TierB, "size"=27, "halign"=1, "valign"=1))
                text(Elements:get("TAX"), table("text"="TOTAL TAX:", "x"=HUDX+47.0, "y"=HUDY+664.0, "w"= 302.0, "h"=43.0, "r"=200, "g"=0, "b"=0, "size"=27, "halign"=1, "valign"=1))
                text(Elements:get("$999M"), table("text"=TaxTotalStr, "x"=HUDX+47.0, "y"=HUDY+707.0, "w"= 302.0, "h"=43.0, "r"=200, "g"=0, "b"=0, "size"=27, "halign"=1, "valign"=1))
                text(Elements:get("PROFIT"), table("text"="TOTAL PROFIT:", "x"=HUDX+47.0, "y"=HUDY+750.0, "w"= 302.0, "h"=43.0, "r"=30, "g"=178, "b"=0, "size"=27, "halign"=1, "valign"=1))
                text(Elements:get("1" + "$999M"), table("text"=ProfitTotalStr, "x"=HUDX+47.0, "y"=HUDY+793.0, "w"= 302.0, "h"=43.0, "r"=30, "g"=178, "b"=0, "size"=27, "halign"=1, "valign"=1))
                box(Elements:get("Rectangle385"), table("x"=HUDX+59.0, "y"=HUDY+575.0, "w"=278.0, "h"=5.0, "r"=255, "g"=215, "b"=0, "radius"=0))
                box(Elements:get("Rectangle388"), table("x"=HUDX+59.0, "y"=HUDY+747.0, "w"=278.0, "h"=5.0, "r"=200, "g"=0, "b"=0, "radius"=0))
                box(Elements:get("Rectangle389"), table("x"=HUDX+59.0, "y"=HUDY+833.0, "w"=278.0, "h"=5.0, "r"=30, "g"=178, "b"=0, "radius"=0))
                box(Elements:get("Rectangle387"), table("x"=HUDX+59.0, "y"=HUDY+661.0, "w"=278.0, "h"=5.0, "r"=TierR, "g"=TierG, "b"=TierB, "radius"=0))
            }
            
            # Continue checking for profit
            if(Snapshot) {
                checkProfit(Customer)
            }
        }
        else {
            # Rack is assigned but customer is invalid - clear HUD and reset tracking variables
            if(CurrentCustomer:isValid() || CurrentRackID != 0) {
                CurrentCustomer = _NO_ENTITY
                CurrentRackID = 0
                Snapshot = 0
                LastCustomerSteamID = ""
                LastTierName = ""
                LastTaxTotal = ""
                LastProfitTotal = ""
                removeCard()
            }
        }
    }
    else {
        # Not looking at a rack - clear if we had something displayed before
        if(CurrentCustomer:isValid() || CurrentRackID != 0) {
            CurrentCustomer = _NO_ENTITY
            CurrentRackID = 0
            Snapshot = 0
            LastCustomerSteamID = ""
            LastTierName = ""
            LastTaxTotal = ""
            LastProfitTotal = ""
            removeCard()
        }
    }
}

# Function to set a manual owner for the currently aimed rack
function void setRackOwner(Player:entity) {
    if(!Player:isValid()) {
        owner():msg("{!yellow [" + BankName + "]} {red Invalid player specified.}")
        return
    }
    
    # Get the currently aimed entity
    let AimEntity = owner():aimEntity()
    if(!AimEntity:isValid() || !checkRack(AimEntity)) {
        owner():msg("{!yellow [" + BankName + "]} {red You need to look at a rack first.}")
        return
    }
    
    let RackID = AimEntity:id()
    
    # Update or create the rack entry in the Racks table
    if(Racks[RackID, table]) {
        # Update existing rack entry
        let OldOwnerSteamID = Racks[RackID, table]["owner", string]
        let OldOwner = OldOwnerSteamID:findPlayer()
        let OldOwnerName = OldOwner:isValid() ? OldOwner:name() : "Unknown"
        
        Racks[RackID, table]["owner", string] = Player:steamID()
        owner():msg("{!yellow [" + BankName + "]} {green Rack owner updated from " + OldOwnerName + " to " + Player:name() + "}")
    } else {
        # Create new rack entry
        Racks[RackID, table] = table()
        Racks[RackID, table]["owner", string] = Player:steamID()
        Racks[RackID, table]["rack_type", string] = "Standard Rack" # Default type
        owner():msg("{!yellow [" + BankName + "]} {green Rack assigned to " + Player:name() + "}")
    }
    # Inform the player that they are now the owner
    Player:msg("{!yellow [" + BankName + "]} {green " + owner():name() + " has assigned you as the owner of a rack}")
}

# Calculate total insurance value for a player
function number calculatePlayerInsurance(SteamID:string) {
    let TotalInsurance = 0
    
    # Get player's printer data (stored by entity ID)
    if(Racks:exists("player_printers")) {
        let AllPrinters = Racks["player_printers", table]
        if(AllPrinters:exists(SteamID)) {
            let PlayerPrinters = AllPrinters[SteamID, table]
            
            # Add up all printer values (each entry is a unique entity)
            foreach(_:number, PrinterInfo:table = PlayerPrinters) {
                let PrinterType = PrinterInfo["type", string]
                let Price = getInsurancePrice(PrinterType)
                TotalInsurance += Price
            }
        }
    }
    
    # Add rack values
    foreach(_:number, RackData:table = Racks) {
        if(RackData["owner", string] == SteamID) {
            let RackType = RackData["rack_type", string]
            TotalInsurance += getInsurancePrice(RackType)
        }
    }
    
    return TotalInsurance
}

# Function to pay insurance to all customers
function void payInsurance() {
    let ProcessedPlayers = table()
    let TotalPaid = 0
    let PlayerCount = 0
    
    owner():msg("{!yellow [" + BankName + "]} {green Starting insurance payouts...}")
    
    # Process each rack owner (for current deposits)
    foreach(_:number, RackData:table = Racks) {
        if(RackData["owner", string]) {
            let SteamID = RackData["owner", string]
            
            # Only process each player once
            if(!ProcessedPlayers:exists(SteamID)) {
                let Customer = SteamID:findPlayer()
                
                # Calculate total insurance value
                let InsuranceValue = calculatePlayerInsurance(SteamID)
                
                # Add crash recovery value ONLY if server crashed flag is set
                if(ServerCrashed) {
                    local CrashValue = CrashRecoveryData[SteamID, number]
                    InsuranceValue += CrashValue
                }
                
                if(InsuranceValue > 0) {
                    # Get player's insurance rate based on tier
                    let InsuranceRate = 0
                    if(Customer:isValid()) {
                        let PlayerTier = getEffectiveTier(Customer, MemberData)
                        InsuranceRate = getTierInsurance(PlayerTier)
                    }
                    
                    let Payout = InsuranceValue * InsuranceRate
                    
                    if(Customer:isValid()) {
                        moneyGive(Customer, Payout)
                        Customer:msg("{!yellow [" + BankName + " INSURANCE]} {green You received $" + formatNumber(Payout) + " insurance payout}")
                        Customer:msg("{!yellow [" + BankName + "]} {yellow Item Value: $" + formatNumber(InsuranceValue) + " | Insurance Rate: " + (InsuranceRate*100) + "%}")
                        
                        TotalPaid += Payout
                        PlayerCount++
                        
                        owner():msg("{green " + Customer:name() + ":} $" + formatNumber(Payout) + " (" + (InsuranceRate*100) + "% of $" + formatNumber(InsuranceValue) + ")")
                    } else {
                        owner():msg("{yellow " + SteamID + " (OFFLINE):} Would receive $" + formatNumber(Payout) + " when they connect")
                    }
                }
                
                ProcessedPlayers[SteamID, number] = 1
            }
        }
    }
    
    # If in crashed mode, also process players from CrashRecoveryData who weren't in Racks
    if(ServerCrashed) {
        foreach(SteamID:string, CrashValue:number = CrashRecoveryData) {
            # Only process if not already processed from Racks
            if(!ProcessedPlayers:exists(SteamID) && CrashValue > 0) {
                let Customer = SteamID:findPlayer()
                
                # Get player's insurance rate based on tier
                let InsuranceRate = 0
                if(Customer:isValid()) {
                    let PlayerTier = getEffectiveTier(Customer, MemberData)
                    InsuranceRate = getTierInsurance(PlayerTier)
                }
                
                let Payout = CrashValue * InsuranceRate
                
                if(Customer:isValid()) {
                    moneyGive(Customer, Payout)
                    Customer:msg("{!yellow [" + BankName + " INSURANCE]} {green You received $" + formatNumber(Payout) + " crash recovery insurance payout}")
                    Customer:msg("{!yellow [" + BankName + "]} {yellow Item Value: $" + formatNumber(CrashValue) + " | Insurance Rate: " + (InsuranceRate*100) + "%}")
                    
                    TotalPaid += Payout
                    PlayerCount++
                    
                    owner():msg("{green " + Customer:name() + " (CRASH):} $" + formatNumber(Payout) + " (" + (InsuranceRate*100) + "% of $" + formatNumber(CrashValue) + ")")
                } else {
                    owner():msg("{yellow " + SteamID + " (OFFLINE/CRASH):} Would of received $" + formatNumber(Payout))
                }
                
                ProcessedPlayers[SteamID, number] = 1
            }
        }
    }
    
    if(PlayerCount > 0) {
        owner():msg("{!yellow [" + BankName + "]} {green Paid $" + formatNumber(TotalPaid) + " to " + PlayerCount + " customers}")
        Racks = table()
        CrashRecoveryData = table()
        fileWrite("cozzahs_bank_crash_recovery.txt", jsonEncode(CrashRecoveryData))
        ServerCrashed = 0
        print("All crash recovery values cleared after insurance payout")
    }
    else {
        owner():msg("{!yellow [" + BankName + "]} {red No customers found or no insurance value}")
    }
}

# Calculate total insurance liability without paying out
function void calculateTotalInsurance() {
    let ProcessedPlayers = table()
    let TotalLiability = 0
    let TotalValue = 0
    let PlayerCount = 0
    
    owner():msg("{#FFBF00 ===================================}")
    owner():msg("{#FFBF00 TOTAL INSURANCE LIABILITY REPORT}")
    owner():msg("{#FFBF00 ===================================}")
    
    # Process each rack owner (for current deposits)
    foreach(_:number, RackData:table = Racks) {
        if(RackData["owner", string]) {
            let SteamID = RackData["owner", string]
            
            # Only process each player once
            if(!ProcessedPlayers:exists(SteamID)) {
                let Customer = SteamID:findPlayer()
                
                # Calculate total insurance value
                let InsuranceValue = calculatePlayerInsurance(SteamID)
                # Add crash recovery value
                local CrashValue = CrashRecoveryData[SteamID, number]
                InsuranceValue += CrashValue
                
                if(InsuranceValue > 0) {
                    TotalValue += InsuranceValue
                    
                    # Get player's insurance rate based on tier
                    let InsuranceRate = 0
                    if(Customer:isValid()) {
                        let PlayerTier = getEffectiveTier(Customer, MemberData)
                        InsuranceRate = getTierInsurance(PlayerTier)
                    }
                    
                    let Payout = InsuranceValue * InsuranceRate
                    TotalLiability += Payout
                    PlayerCount++
                    
                    if(Customer:isValid()) {
                        owner():msg("{green " + Customer:name() + ":} $" + formatNumber(Payout) + " (" + (InsuranceRate*100) + "% of $" + formatNumber(InsuranceValue) + ")")
                    } else {
                        owner():msg("{yellow " + SteamID + " (OFFLINE):} $" + formatNumber(Payout) + " (" + (InsuranceRate*100) + "% of $" + formatNumber(InsuranceValue) + ")")
                    }
                }
                
                ProcessedPlayers[SteamID, number] = 1
            }
        }
    }
    
    # Also process players from CrashRecoveryData who weren't in Racks
    foreach(SteamID:string, CrashValue:number = CrashRecoveryData) {
        # Only process if not already processed from Racks
        if(!ProcessedPlayers:exists(SteamID) && CrashValue > 0) {
            let Customer = SteamID:findPlayer()
            
            TotalValue += CrashValue
            
            # Get player's insurance rate based on tier
            let InsuranceRate = 0
            if(Customer:isValid()) {
                let PlayerTier = getEffectiveTier(Customer, MemberData)
                InsuranceRate = getTierInsurance(PlayerTier)
            }
            
            let Payout = CrashValue * InsuranceRate
            TotalLiability += Payout
            PlayerCount++
            
            if(Customer:isValid()) {
                owner():msg("{green " + Customer:name() + " (CRASH):} $" + formatNumber(Payout) + " (" + (InsuranceRate*100) + "% of $" + formatNumber(CrashValue) + ")")
            } else {
                owner():msg("{yellow " + SteamID + " (OFFLINE/CRASH):} $" + formatNumber(Payout) + " (" + (InsuranceRate*100) + "% of $" + formatNumber(CrashValue) + ")")
            }
            
            ProcessedPlayers[SteamID, number] = 1
        }
    }
    
    owner():msg("{#FFBF00 ===================================}")
    owner():msg("{#FFBF00 TOTAL CUSTOMERS: }{green " + PlayerCount + "}")
    owner():msg("{#FFBF00 TOTAL ITEM VALUE: }{green $" + formatNumber(TotalValue) + "}")
    owner():msg("{#FFBF00 TOTAL LIABILITY: }{green $" + formatNumber(TotalLiability) + "}")
    owner():msg("{#FFBF00 ===================================}")
}

# Manual printer setter command (fixed for entity ID system)
function void setPlayerPrinters(Player:entity, PrinterType:string, Count:number) {
    if(!Player:isValid()) {
        owner():msg("{!yellow [" + BankName + "]} {red Invalid player}")
        return
    }
    
    let SteamID = Player:steamID()
    
    # Initialize storage if needed
    if(!Racks:exists("player_printers")) {
        Racks["player_printers", table] = table()
    }
    
    let AllPrinters = Racks["player_printers", table]
    if(!AllPrinters:exists(SteamID)) {
        AllPrinters[SteamID, table] = table()
    }
    
    let PlayerPrinters = AllPrinters[SteamID, table]
    
    if(Count > 0) {
        # First, remove all existing printers of this type
        let ToRemove = array()
        foreach(PrinterID:number, PrinterInfo:table = PlayerPrinters) {
            if(PrinterInfo["type", string] == PrinterType) {
                ToRemove:pushNumber(PrinterID)
            }
        }
        foreach(_:number, ID:number = ToRemove) {
            PlayerPrinters:remove(ID)
        }
        
        # Now add the new count with fake entity IDs
        # Use negative IDs to avoid conflicts with real entity IDs
        # Start from a high negative number and count down
        let FakeIDStart = -1000000 - (SteamID:toNumber() % 100000) * 1000
        let UsedIDs = table()
        
        # Check what fake IDs are already in use for this player
        foreach(PrinterID:number, _:table = PlayerPrinters) {
            if(PrinterID < 0) {
                UsedIDs[PrinterID, number] = 1
            }
        }
        
        # Add new printers with unique fake IDs
        let AddedCount = 0
        let CurrentFakeID = FakeIDStart
        while(AddedCount < Count) {
            # Find next unused fake ID
            while(UsedIDs:exists(CurrentFakeID)) {
                CurrentFakeID--
            }
            
            PlayerPrinters[CurrentFakeID, table] = table("type" = PrinterType)
            UsedIDs[CurrentFakeID, number] = 1
            CurrentFakeID--
            AddedCount++
        }
        
        owner():msg("{!yellow [" + BankName + "]} {green Set " + Player:name() + "'s " + PrinterType + " count to " + Count + "}")
        Player:msg("{!yellow [" + BankName + "]} {green Your " + PrinterType + " count has been set to " + Count + " by} {yellow " + owner():name() + "}.")
    }
    else {
        # Remove all printers of this type
        let ToRemove = array()
        foreach(PrinterID:number, PrinterInfo:table = PlayerPrinters) {
            if(PrinterInfo["type", string] == PrinterType) {
                ToRemove:pushNumber(PrinterID)
            }
        }
        foreach(_:number, ID:number = ToRemove) {
            PlayerPrinters:remove(ID)
        }
        
        owner():msg("{!yellow [" + BankName + "]} {green Removed all " + PrinterType + " from " + Player:name())
    }
    # Calculate the insurance value being added
    local AddedValue = getInsurancePrice(PrinterType) * Count
    saveCrashRecoveryValue(SteamID, AddedValue)
}

# sends all customers a bank closing notifications
function void close(Minutes:number, Amount:number) {
    let Time = 60 * Minutes
    let NotifNum = Amount
    let Interval = Time / NotifNum
    print("Time = " + Time)
    print("NotifNum = " + NotifNum)
    print("Interval = " + Interval)
    
    function void sendMessage(TimeLeft:string) {
        let MessagedPlayers = table()
        foreach(_:number, RackData:table = Racks) {
            let SteamID = RackData["owner", string]
            
            # Skip if we already messaged this player
            if(MessagedPlayers:exists(SteamID)) { continue }
            
            let Customer = SteamID:findPlayer()
            if(Customer:isValid()) {
                Customer:msg("{! [" + BankName + " ALERT]}  " + BankName:lower() + " bank will be closing in {yellow " + TimeLeft + "}. Please pick up your printers or they will be {red destroyed}.")
                MessagedPlayers[SteamID, number] = 1
            }
        }
    }
    
    # Send the first message immediately when function is called
    let TimeFormat = formatTimeInSeconds(Time)
    if(TimeFormat != "") {
        sendMessage(TimeFormat)
        print("{! [" + BankName + " ALERT]} Closing notification sent. {yellow " + TimeFormat + "} till closing.")
        Time = Time - Interval
    }
    else { print("{! [ERROR] } {red 'TimeFormat' = null }") }
    
    timer("closing", Interval, NotifNum, function() {
        if(Time > 0) {
            let TimeFormat = formatTimeInSeconds(Time)
            if(TimeFormat != "") {
                sendMessage(TimeFormat)
                print("{! [" + BankName + " ALERT]} Closing notification sent. {yellow " + TimeFormat + "} till closing.") 
                Time = Time - Interval
            }
            else { print("{! [ERROR] } {red 'TimeFormat' = null }") }
        }
        else {
            stoptimer("closing")
            let MessagedPlayers = table()
            foreach(_:number, RackData:table = Racks) {
                let SteamID = RackData["owner", string]
                
                # Skip if we already messaged this player
                if(MessagedPlayers:exists(SteamID)) { continue }
                
                let Customer = SteamID:findPlayer()
                if(Customer:isValid()) {
                    Customer:msg("{! [" + BankName + " ALERT]} {red  " + BankName:lower() + " bank has closed. If you have not picked up your printers they will now be } {! destroyed}{red .}")
                    MessagedPlayers[SteamID, number] = 1
                }
            }
            print("{! [" + BankName + " ALERT]} Bank closed, you may {! destroy } remaining printers") 
        }
    })
}

# Function to display all customers and their tiers
function void displayAllCustomers() {
    let CustomerCount = 0
    
    # Header display
    owner():msg("{#FFBF00 === CUSTOMER LIST ===}")
    
    # Loop through all racks
    foreach(_:number, RackData:table = Racks) {
        if(RackData["owner", string]) {
            let SteamID = RackData["owner", string]
            let Customer = SteamID:findPlayer()
            
            if(Customer:isValid()) {
                # Get tier name for this customer
                let PlayerTier = getMemberDataTier(Customer, MemberData)
                let TierName = getTierName(PlayerTier):upper()
                let TierColor = getTierColor(PlayerTier)
                let TaxTotal = RackData["tax_total", number] || 0
                let ProfitTotal = RackData["profit_total", number] || 0
                
                # Display customer info with color based on tier
                owner():msg("{" + TierColor + " " + Customer:name() + " - " + TierName + " TIER} - Tax: {red $" + formatNumber(TaxTotal) + "} | Profit: {green $" + formatNumber(ProfitTotal) + "}")
                
                CustomerCount++
            }
            else {
                print("{! COULD NOT FIND PLAYER} {blue '" + SteamID + "}.")
            }
        }
    }
    
    # Display count message if no customers found
    if(CustomerCount == 0) {
        owner():msg("{#FFBF00 No active customers found.}")
    }
    else {
        owner():msg("{#FFBF00 Total Customers: }{green " + CustomerCount + "}")
    }
    
    # Footer display
    owner():msg("{#FFBF00 ====================}")
}

# Function to display total tax profit from all racks
function void displayTotalProfit() {
    let TotalTax = 0
    let TotalProfit = 0
    let RackCount = 0
    
    # Loop through all racks and sum their totals
    foreach(_:number, RackData:table = Racks) {
        if(RackData["tax_total", number]) {
            TotalTax += RackData["tax_total", number]
            TotalProfit += RackData["profit_total", number]
            RackCount++
        }
    }
    
    # Header display
    owner():msg("{#FFBF00 === PROFIT SUMMARY ===}")
    
    # Show session totals
    owner():msg("{#FFBF00 Session Tax Collected: }{green $" + formatNumber(TotalTax) + "}")
    owner():msg("{#FFBF00 Session Profit Paid Out: }{green $" + formatNumber(TotalProfit) + "}")
    owner():msg("{#FFBF00 Number of Racks: }{green " + RackCount + "}")
    
    # Calculate averages
    if(RackCount > 0) {
        let AverageTaxPerRack = TotalTax / RackCount
        let AverageProfitPerRack = TotalProfit / RackCount
        owner():msg("{#FFBF00 Average Tax per Rack: }{green $" + formatNumber(AverageTaxPerRack) + "}")
        owner():msg("{#FFBF00 Average} {blue Player} {#FFBF00 Profit per Rack: }{green $" + formatNumber(AverageProfitPerRack) + "}")
    }
    
    # Separator
    owner():msg("{#FFBF00 =====================}")
    
    # Show average profit per hour (works for any time frame)
    let ElapsedSeconds = curtime() - RackProfitStartTime
    let ElapsedMinutes = ElapsedSeconds / 60
    let ElapsedHours = ElapsedSeconds / 3600
    
    if(ElapsedSeconds > 0) {
        let AvgPerHour = (OverallTotalProfit / ElapsedSeconds) * 3600
        owner():msg("{#FFBF00 Average Profit/Hour: }{green $" + formatNumber(AvgPerHour) + "}")
        
        # Show tracking time in appropriate units
        if(ElapsedHours >= 1) {
            owner():msg("{#FFBF00 Tracking Time: }{green " + floor(ElapsedHours * 100) / 100 + " hours}")
        }
        elseif(ElapsedMinutes >= 1) {
            owner():msg("{#FFBF00 Tracking Time: }{green " + floor(ElapsedMinutes * 10) / 10 + " minutes}")
        }
        else {
            owner():msg("{#FFBF00 Tracking Time: }{green " + floor(ElapsedSeconds) + " seconds}")
        }
    }
    
    # Footer display
    owner():msg("{#FFBF00 =====================}")
}

function void displayPlayerInsurance(Player:entity) {
    let SteamID = Player:steamID()
    let TotalValue = 0
    
    owner():msg("{#FFBF00 ================================}")
    owner():msg("{#FFBF00 INSURANCE REPORT: }{green " + Player:name() + "}")
    owner():msg("{#FFBF00 ================================}")
    
    # Show printers
    if(Racks:exists("player_printers")) {
        let AllPrinters = Racks["player_printers", table]
        if(AllPrinters:exists(SteamID)) {
            let PlayerPrinters = AllPrinters[SteamID, table]
            
            # Count printers by type
            let PrinterCounts = table()
            foreach(_:number, PrinterInfo:table = PlayerPrinters) {
                let PrinterType = PrinterInfo["type", string]
                let CurrentCount = PrinterCounts[PrinterType, number]
                PrinterCounts[PrinterType, number] = CurrentCount + 1
            }
            
            # Display counts
            owner():msg("{#FFBF00 PRINTERS:}")
            foreach(PrinterType:string, Count:number = PrinterCounts) {
                let Price = getInsurancePrice(PrinterType)
                let SubTotal = Price * Count
                TotalValue += SubTotal
                
                # Color code by tier
                let Color = "{green "
                if(PrinterType == "Legendary") { Color = "{#E0B433 " }
                elseif(PrinterType == "Epic") { Color = "{#571F82 " }
                elseif(PrinterType == "VIP+") { Color = "{#7F1D6E " }
                elseif(PrinterType == "VIP") { Color = "{#9F1D1D " }
                elseif(PrinterType == "Tier 5") { Color = "{#FF1D1B " }
                elseif(PrinterType == "Basic") { Color = "{#20BC92 " }
                elseif(PrinterType == "Advanced") { Color = "{#22ABE2 " }
                elseif(PrinterType == "Christmas") { Color = "{#FF0000 " }
                elseif(PrinterType == "Booster") { Color = "{#FF00BF " }
                elseif(PrinterType == "Booster") { Color = "{#dc3545 " }
                elseif(PrinterType == "Halloween") { Color = "{#EB6123 " }
                elseif(PrinterType == "BitMiner Rack") { Color = "{#C8C8C8 " }
                
                owner():msg("  " + Color + Count + "x " + PrinterType + ":} {green $" + formatNumber(SubTotal) + "}")
            }
        } else {
            owner():msg("{#FFBF00 PRINTERS:}")
            owner():msg("  {red None}")
        }
    }
    else {
        owner():msg("{#FFBF00 PRINTERS:}")
        owner():msg("  {red None}")
    }
    
    # Show racks
    let RackCount = 0
    owner():msg("{#FFBF00 RACKS:}")
    foreach(_:number, RackData:table = Racks) {
        if(RackData["owner", string] == SteamID) {
            let RackType = RackData["rack_type", string]
            let RackPrice = getInsurancePrice(RackType)
            TotalValue += RackPrice
            RackCount++
            owner():msg("  {green " + RackType + ": $" + formatNumber(RackPrice) + "}")
        }
    }
    
    if(RackCount == 0) {
        owner():msg("  None")
    }
    
    # Show crash recovery value
    if(CrashRecoveryData:exists(SteamID)) {
        let CrashValue = CrashRecoveryData[SteamID, number]
        if(CrashValue > 0) {
            TotalValue += CrashValue
            owner():msg("{#FFBF00 CRASH RECOVERY VALUE: }{yellow $" + formatNumber(CrashValue) + "}")
        }
    }
    
    # Calculate insurance payout
    let PlayerTier = getEffectiveTier(Player, MemberData)
    let InsuranceRate = getTierInsurance(PlayerTier)
    let Payout = TotalValue * InsuranceRate
    
    owner():msg("{#FFBF00 TOTAL VALUE: }{green $" + formatNumber(TotalValue) + "}")
    owner():msg("{#FFBF00 INSURANCE RATE: }{green " + (InsuranceRate*100) + "%} (" + getTierName(PlayerTier) + " tier)")
    owner():msg("{#FFBF00 PAYOUT: }{green $" + formatNumber(Payout) + "}")
    owner():msg("{#FFBF00 ================================}")
}

function void timerdraw() {
    box(Elements:get("Rectangle307"), table("x"=800.0, "y"=-59.0, "w"=319.0, "h"=166.0, "r"=42, "g"=42, "b"=42, "radius"=30.0))
    box(Elements:get("Rectangle306"), table("x"=803.0, "y"=-59.0, "w"=313.0, "h"=163.0, "r"=255, "g"=255, "b"=255, "radius"=30.0))
    box(Elements:get("Rectangle305"), table("x"=803.0, "y"=-115.0, "w"=313.0, "h"=163.0, "r"=80, "g"=80, "b"=80, "radius"=0.0))
    text(Elements:get("COLLECTIONTIME"), table("text"="COLLECTION TIME:", "x"=803.0, "y"=-10.0, "w"= 313.0, "h"=76.0, "r"=255, "g"=255, "b"=255, "size"=35, "halign"=1, "valign"=1))
    text(Elements:get("/Min/Sec"), table("text"="UNKNOWN", "x"=803.0, "y"=36.0, "w"= 313.0, "h"=63.0, "r"=0, "g"=0, "b"=0, "size"=35, "halign"=1, "valign"=1))
    
    HUD:egpAlpha(Elements:get("Rectangle307"),150)
    HUD:egpAlpha(Elements:get("Rectangle306"),150)
    HUD:egpAlpha(Elements:get("Rectangle305"),150)
}    

function void sendReq() {
    broadcastRemoteEvent(table())
} 

function void displayAdminHelp() {
    # Send header
    owner():msg("{#FFBF00 === ADMIN COMMANDS (BANKER MAIN) ===}")
    
    # Admin commands
    owner():msg("{#FFBF00 *help} - Shows this admin help message")
    owner():msg("{#FFBF00 *clearcrash} - clears crash file{! (should be done at start of every session)}")
    owner():msg("{#FFBF00 *close 'minutes' 'notifs'} - Sends closing notifications")
    owner():msg("{#FFBF00 *customers} - Shows list of all customers with tiers")
    owner():msg("{#FFBF00 *profit} - Shows total profit summary from all racks")
    owner():msg("{#FFBF00 *reseavg} - Resets the overall rack profit per hour calculation")
    owner():msg("{#FFBF00 *wire 'player' 'amount'} - Sends money to player")
    owner():msg("{#FFBF00 *owner 'player'} - Sets player as owner of last aimed rack")
    owner():msg("{#FFBF00 *raided} - Notifies all customers that bank was raided")
    owner():msg("{#FFBF00 *insurance} - Pays insurance to ALL customers")
    owner():msg("{#FFBF00 *checkinsurance 'player'} - Shows player's insurance info")
    owner():msg("{#FFBF00 *totalinsurance} - Shows total insurance liability without paying")
    owner():msg("{#FFBF00 *crashed} - Enable crash recovery mode for next insurance payout")
    owner():msg("{#FFBF00 *setprinter 'player' 'type' 'count'} - Manually set printer count")
    owner():msg("{#FFBF00 Types: Basic, Advanced, Tier 5, VIP, VIP+, Epic, Legendary, Halloween, Christmas, Booster, Black Wing, BitMiner Rack}")
    
    # Send footer
    owner():msg("{#FFBF00 ==================================}")
}

function void cmdAdmin(Command:string, Args:array) {
    if(Command == "HELP") {
        displayAdminHelp()
    }
    elseif(Command == "WIRE") {
        if(Args:count() >= 2) {
            let PlayerName = Args[1, string]
            let Player = PlayerName:findPlayer()
            let Amount = Args[2, string]:toNumber()
            if(Player:isValid() && Amount > 1000) {
                moneyGive(Player,Amount)
                owner():msg("{yellow [" + BankName + " E2] } YOU HAVE SENT {green " + formatNumber(Amount) + "} TO {*" + Player:name():upper() + "}")
                Player:msg("{yellow [" + BankName + " E2] } {*" + limitNameLength(BankName,10) + "} HAS SENT YOU {green " + formatNumber(Amount) + "}")
            }
            else { print("{! Player or Amount INVALID}") }      
        }
        else { print("{! usage} - {yellow *wire 'player' 'amount'} amount must be bigger than 100") }
    }
    elseif(Command == "OWNER") {
        if(Args:count() >= 1) {
            let PlayerName = Args[1, string]
            let Player = PlayerName:findPlayer()
            if(Player:isValid()) {
                setRackOwner(Player)
            }
            else {
                owner():msg("{!yellow [" + BankName + "]} {red Player not found.}")
            }
        }
        else {
            owner():msg("{!yellow [" + BankName + "]} {red Usage: *owner 'player'}")
        }
    }
    elseif(Command == "PROFIT") {
        displayTotalProfit()
    }
    elseif(Command == "CLOSE") {
        if(Args:count() >= 1) {
            let Minutes = Args[1, string]:toNumber()
            let NotifNum = Args[2, string]:toNumber()
            close(Minutes, NotifNum)
        }
    }
    elseif(Command == "CUSTOMERS") {
        displayAllCustomers()
    }
    elseif(Command == "INSURANCE") {
        payInsurance()
    }
    elseif(Command == "CRASHED") {
        ServerCrashed = 1
        hideChat(1)
        print("{!yellow [" + BankName + "]} {green Server crash mode ENABLED. Next insurance payout will include crash recovery values.}")
    }
    elseif(Command == "CLEARCRASH") {
        hideChat(1)
        CrashRecoveryData = table()
        fileWrite("cozzahs_bank_crash_recovery.txt", jsonEncode(CrashRecoveryData))
        ServerCrashed = 0
        print("Crash recovery data cleared manually")
    }
    elseif(Command == "CHECKINSURANCE") {
        if(Args:count() >= 1) {
            let PlayerName = Args[1, string]
            let Player = PlayerName:findPlayer()
            if(Player:isValid()) {
                displayPlayerInsurance(Player)
            }
            else {
                owner():msg("{!yellow [" + BankName + "]} {red Player not found.}")
            }
        }
        else {
            owner():msg("{!yellow [" + BankName + "]} {red Usage: *checkinsurance 'player'}")
        }
    }
    elseif(Command == "TOTALINSURANCE") {
        calculateTotalInsurance()
    }
    elseif(Command == "SETPRINTER") {
        if(Args:count() >= 3) {
            let PlayerName = Args[1, string]
            let Player = PlayerName:findPlayer()
            let PrinterType = Args[2, string]
            let Count = Args[3, string]:toNumber()
            
            if(Player:isValid()) {
                # Validate printer type
                let ValidTypes = array("Basic", "Advanced", "Tier 5", "VIP", "VIP+", "Epic", "Legendary", "Halloween", "Booster", "Black Wing")
                let IsValid = 0
                
                for(I = 1, ValidTypes:count()) {
                    if(ValidTypes[I, string]:upper() == PrinterType:upper()) {
                        PrinterType = ValidTypes[I, string]
                        IsValid = 1
                        break
                    }
                }
                
                if(IsValid) {
                    setPlayerPrinters(Player, PrinterType, Count)
                }
                else {
                    owner():msg("{!yellow [" + BankName + "]} {red Invalid printer type. Valid types: Basic, Advanced, Tier 5, VIP, VIP+, Epic, Legendary, Halloween, Booster, Black Wing}")
                }
            }
            else {
                owner():msg("{!yellow [" + BankName + "]} {red Player not found.}")
            }
        }
        else {
            owner():msg("{!yellow [" + BankName + "]} {red Usage: *setprinter 'player' 'type' 'count'}")
        }
    }
    elseif(Command == "COPS") {
        let Amount = 50000
        if(Amount) {
            let Count = 0
            findIncludeClass("player")
            findInSphere(entity():pos(),1000)
            let Players = findToTable()
            foreach(_:number, Player:entity = Players) {
                let Job = Player:team():teamName()
                let IsLawEnforcement = 0
                for(I = 1, JOB:count()) {
                    if(JOB[I, string] == Job) {
                        IsLawEnforcement = 1
                        break
                    }
                }
                if(IsLawEnforcement) {
                    moneyGive(Player,Amount)
                    Player:msg("{!yellow [" + BankName + "]} You received ${green " + Amount + "} for {blue defending} {yellow " + BankName:lower() + "}.")
                    Count++
                }
            }
            print("{!yellow [" + BankName + "]} You paid $" + Amount + " to " + Count + " law enforcement players")
        }
        else{ print("{! INVALID INPUT}") }
    }
    elseif(Command == "RESEAVG") {
        # Reset rack profit tracking
        RackProfitStartTime = curtime()
        owner():msg("{!yellow [" + BankName + "]} {green Rack profit average has been reset. Starting fresh from now.}")
    }
}

if(first() || dupefinished()) {
    HUD:egpClear()
    HUD:egpDrawTopLeft(1)
    
    sendReq()
    timer(60,0,function() {
        sendReq()
    })
    timer(0.1, 0, function() {
        checkCollection()
    })
    timer("Timer",600,0,function() {
        print("{! [" + BankName + "] } {!green time to collect from printer}")
        owner():soundPlay(0,1,"zmlab2/cash.wav")
    })
    
    timer("TimeLeft",1,0,function() {
        TimeLeft = timerTimeLeft("Timer")
        
        if(!HUD:egpHasObject(Elements:get("Rectangle307"))) {
            timerdraw()
        }
        else {
            HUD:egpSetText(Elements:get("/Min/Sec"), formatTimeInSeconds(TimeLeft))
        }
    })
    
    # Update average profit per hour every 5 mins (works for any time elapsed)
    timer("updateAvgProfit", 300, 0, function() {
        let ElapsedSeconds = curtime() - RackProfitStartTime
        
        # Convert to per-hour rate even if only seconds/minutes have passed
        if(ElapsedSeconds > 0) {
            # Calculate: (profit per second) * (seconds in an hour)
            RackAvgProfitPerHour = (OverallTotalProfit / ElapsedSeconds) * 3600
        }
        else {
            RackAvgProfitPerHour = 0
        }
    })
    
    loadOverallTotals()
    loadCrashRecoveryData()
    hint("USE *CLEARCRASH to clear crash file at the start of every session",10)
    owner():msg("{orange [WARNING]} {!  USE} {yellow *CLEARCRASH} {! to clear crash file at the start of every session}")
}

event remote(Sender:entity, Player:entity, Payload:table) {    
    if (Player == owner()) {
        if(Sender == findE2ByName("Cozzah's bank security v1.2",200)) {
            Guards = Payload
            #print("{blue " + Sender:getName() + "} table has been loaded with {yellow " + Payload:count() + "} entries.")
        }
        elseif(Sender == findE2ByName("Cozzah's Banker E2 Membership",200)) {
            MemberData = Payload
            #print("{green " + Sender:getName() + "} table has been loaded with {yellow " + Payload:count() + "} entries.")
        }
        elseif(Sender == findE2ByName("Cozzah's Banker E2 Depo",200)) {
            # Received rack assignments and printer data from depo E2
            let RacksData = Payload["racks", table]
            let PrintersData = Payload["printers", table]
            
            let NewRackCount = 0
            let SkippedRackCount = 0
            foreach(RackID:number, RackData:table = RacksData) {
                # Only add racks that don't already exist (preserves ownership set by *owner command)
                if(!Racks:exists(RackID)) {
                    Racks[RackID, table] = RackData
                    NewRackCount++
                } else {
                    SkippedRackCount++
                }
            }
            
            if(NewRackCount > 0) {
                print("{cyan [Depo]} Added " + NewRackCount + " NEW rack assignments")
            }
            if(SkippedRackCount > 0) {
                print("{yellow [Depo]} Skipped " + SkippedRackCount + " racks (already owned)")
            }
            
            # Store printer data by entity ID (prevents duplicates)
            foreach(SteamID:string, PrinterList:table = PrintersData) {
                if(!Racks:exists("player_printers")) {
                    Racks["player_printers", table] = table()
                }
                
                # Initialize this player's printer data if it doesn't exist
                if(!Racks["player_printers", table]:exists(SteamID)) {
                    Racks["player_printers", table][SteamID, table] = table()
                }
                
                # Add only NEW printer entities (by ID) and calculate crash recovery value
                let ExistingPrinters = Racks["player_printers", table][SteamID, table]
                local TotalInsuranceValue = 0
                
                foreach(PrinterID:number, PrinterInfo:table = PrinterList) {
                    if(!ExistingPrinters:exists(PrinterID)) {
                        ExistingPrinters[PrinterID, table] = PrinterInfo
                        # Add to crash recovery value
                        local PrinterType = PrinterInfo["type", string]
                        TotalInsuranceValue += getInsurancePrice(PrinterType)
                    }
                }
                
                # Also add rack values for this player's racks
                foreach(_:number, RackData:table = RacksData) {
                    if(RackData["owner", string] == SteamID) {
                        local RackType = RackData["rack_type", string]
                        TotalInsuranceValue += getInsurancePrice(RackType)
                    }
                }
                
                # Save crash recovery value if any items were deposited
                if(TotalInsuranceValue > 0) {
                    saveCrashRecoveryValue(SteamID, TotalInsuranceValue)
                }
            }
            
            
            if(NewRackCount > 0) {
                print("{cyan [Depo]} Received " + NewRackCount + " rack assignments and printer data from Depo E2")
            }
        }
    }
}

event chat(Player:entity, Message:string, _:number) {
    if(Player == owner() && Message:sub(1, 1) == "*") {
        let Args = Message:explode(" ")
        let Command = Args[1, string]:upper()
        Args:remove(1)
        cmdAdmin(Command:sub(2), Args)
        hideChat(1)
    }
}

event fileLoaded(File:string, Data:string) {
    if(File == "banker_overall_totals.txt") {
        if(Data != "") {
            let LoadedData = jsonDecode(Data)
            
            if(LoadedData:count() > 0) {
                OverallTotalTax = LoadedData["overall_tax", number]
                OverallTotalProfit = LoadedData["overall_profit", number]
                owner():msg("{!yellow [" + BankName + "]} {green Loaded overall totals: Tax $" + formatNumber(OverallTotalTax) + ", Profit $" + formatNumber(OverallTotalProfit) + "}")
            }
        }
        else {
            print("No overall totals file found, starting fresh")
            OverallTotalTax = 0
            OverallTotalProfit = 0
        }
    }
    elseif(File == "cozzahs_bank_crash_recovery.txt") {
        if(Data != "") {
            local LoadedData = jsonDecode(Data)
            if(LoadedData) {
                CrashRecoveryData = LoadedData
                print("Loaded crash recovery data for " + CrashRecoveryData:count() + " players")
            }
            else {
                CrashRecoveryData = table()
            }
        }
        else {
            CrashRecoveryData = table()
        }
    }
}


